/*
 * Copyright (c) 2010 Daniel Rinehart <danielr@neophi.com> [http://danielr.neophi.com/]
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package com.neophi.zeo.view
{
    import flash.display.Graphics;
    import flash.events.MouseEvent;
    import flash.geom.Point;

    import mx.charts.chartClasses.BoundedValue;
    import mx.charts.chartClasses.CartesianTransform;
    import mx.charts.chartClasses.ChartElement;
    import mx.charts.chartClasses.DataDescription;
    import mx.controls.Label;

    /**
     * Code adapted from: http://demo.quietlyscheming.com/overlayDemo/index.html
     */
    public class RangeSelector extends ChartElement
    {
        /* the bounds of the selected region*/
        private var dLeft:Number = 20;

        private var dTop:Number = 20;

        private var dRight:Number = 80;

        private var dBottom:Number = 80;

        /* the x/y coordinates of the start of the tracking region */
        private var tX:Number;

        private var tY:Number;

        /* whether or not a region is selected */
        private var bSet:Boolean;

        /* whether or not we're currently tracking */
        private var bTracking:Boolean;

        /* the current position of the crosshairs */
        private var _crosshairs:Point;

        /* the four labels for the data bounds of the selected region */
        private var _labelLeft:Label;

        private var _labelRight:Label;

        private var _labelMiddle:Label;

        /* constructor */
        public function RangeSelector():void
        {
            /* mousedowns are where we start tracking the selection */
            addEventListener(MouseEvent.MOUSE_DOWN, startTracking);

            /* mousemove and rollout are used to track the crosshairs */
            addEventListener(MouseEvent.MOUSE_MOVE, updateCrosshairs);
            addEventListener(MouseEvent.ROLL_OUT, removeCrosshairs);

            /* create our labels */
            _labelLeft = new Label();
            _labelRight = new Label();
            _labelMiddle = new Label();
            addChild(_labelLeft);
            addChild(_labelRight);
            addChild(_labelMiddle);
        }

        /* to make sure we end up in any ranges autogenerated by the axes, we need to describe our data to them
         */
        override public function describeData(dimension:String, requiredFields:uint):Array
        {
            /* if no region is selected, we have no data */
            if (bSet == false)
            {
                return [];
            }

            var dd:DataDescription = new DataDescription();


            if (dimension == CartesianTransform.HORIZONTAL_AXIS)
            {
                /* describe the minimum and maximum values we need on screen */
                dd.min = dLeft;
                dd.max = dRight;


                if ((requiredFields & DataDescription.REQUIRED_BOUNDED_VALUES) != 0)
                {
                    /* since we don't want our labels sticking off the edge of the chart, we need to ask for 'bounded values' around the selected data.
                     *  a bounded value is a pixel margin to the left/right of a specific data point. In this case, we'll ask for the width of our labels
                     */
                    dd.boundedValues = [new BoundedValue(dLeft),
                            new BoundedValue(dRight, _labelMiddle.width / 2, 24 + _labelMiddle.width)]
                }
            }
            else
            {
                dd.min = dBottom;
                dd.max = dTop;

                if ((requiredFields & DataDescription.REQUIRED_BOUNDED_VALUES) != 0)
                {
                    /* since we don't want our labels sticking off the edge of the chart, we need to ask for 'bounded values' around the selected data.
                     *  a bounded value is a pixel margin to the top/bottom of a specific data point. In this case, we'll ask for the height of our labels
                     */
                    dd.boundedValues = [new BoundedValue(dTop),
                            new BoundedValue(dBottom, 24 + _labelMiddle.height)]
                }
            }

            return [dd];
        }


        override public function mappingChanged():void
        {
            /* since we store our selection in data coordinates, we need to redraw when the mapping between data coordinates and screen coordinates changes
             */
            invalidateDisplayList();
        }

        /* draw the overlay */
        override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void
        {
            super.updateDisplayList(unscaledWidth, unscaledHeight);

            var g:Graphics = graphics;
            g.clear();

            // draw a big transparent square so the flash player sees us for mouse events */
            g.moveTo(0, 0);
            g.lineStyle(0, 0, 0);
            g.beginFill(0, 0);
            g.drawRect(0, 0, unscaledWidth, unscaledHeight);
            g.endFill();

            /* draw the crosshairs. Crosshairs are drawn where the mouse is, only when the mouse is over us, so we don't need to transform
             *    to data coordinates
             */
            if (_crosshairs != null)
            {
                g.lineStyle(1, 0x005364, .5);

                g.moveTo(_crosshairs.x, 0);
                g.lineTo(_crosshairs.x, unscaledHeight);
            }

            /* draw the selected region, if there is one */
            if (bSet)
            {
                /* the selection is a data selection, so we want to make sure the region stays correct as the chart changes size and/or ranges.
                 *  so we store it in data coordaintes. So before we draw it, we need to transform it back into screen coordaintes
                 */
                var c:Array = [{dx: dLeft, dy: dTop}, {dx: dRight, dy: dBottom}];
                dataTransform.transformCache(c, "dx", "x", "dy", "y");

                /* now draw the region on screen */
                g.moveTo(c[0].x, 0);
                g.beginFill(0xEEEE22, .2);
                g.lineStyle(2, 0xBBBB22);
                g.drawRect(c[0].x, 0, c[1].x - c[0].x, unscaledHeight);
                g.endFill();


                /* now we're going to draw the decorators indicating the bottom and right edges of the box
                 */
                g.lineStyle(2, 0x995522);

                // draw bottom line
                var lineY:Number = unscaledHeight / 4;
                g.moveTo(c[0].x, lineY + 9);
                g.lineTo(c[0].x, lineY + 15);
                g.moveTo(c[0].x, lineY + 12);
                g.lineTo(c[1].x, lineY + 12);
                g.moveTo(c[1].x, lineY + 9);
                g.lineTo(c[1].x, lineY + 15);

                /* now we're going to position the labels at the edges of the box */
                _labelMiddle.visible = true;
                _labelMiddle.setActualSize(_labelMiddle.measuredWidth, _labelMiddle.measuredHeight);
                _labelMiddle.move(c[0].x + (c[1].x - c[0].x) / 2 - _labelMiddle.width / 2, lineY + 24);
            }
            else
            {
                _labelMiddle.visible = false;
            }
        }

        override protected function commitProperties():void
        {
            super.commitProperties();

            _labelMiddle.text = String(Math.round(dRight) - Math.round(dLeft)) + " Minutes";
        }

        private function startTracking(e:MouseEvent):void
        {
            /* the user clicked the mouse down. First, we need to add listeners for the mouse dragging */
            bTracking = true;
            parentApplication.addEventListener(MouseEvent.MOUSE_UP, endTracking, true);
            parentApplication.addEventListener(MouseEvent.MOUSE_MOVE, track, true);

            /* now store off the data values where the user clicked the mouse */
            var dataVals:Array = dataTransform.invertTransform(mouseX, mouseY);
            tX = dataVals[0];
            tY = dataVals[1];
            bSet = false;

            updateTrackBounds(dataVals);
        }

        private function track(e:MouseEvent):void
        {
            if (bTracking == false)
            {
                return;
            }
            bSet = true;
            updateTrackBounds(dataTransform.invertTransform(mouseX, mouseY));
            e.stopPropagation();
        }

        private function endTracking(e:MouseEvent):void
        {
            /* the selection is complete, so remove our listeners and update one last time to match the final position of the mouse */
            bTracking = false;
            parentApplication.removeEventListener("mouseUp", endTracking, true);
            parentApplication.removeEventListener("mouseMove", track, true);
            e.stopPropagation();
            updateTrackBounds(dataTransform.invertTransform(mouseX, mouseY));
        }

        private function updateCrosshairs(e:MouseEvent):void
        {
            /* the mouse moved over the chart, so grab the mouse coordaintes and redraw */
            _crosshairs = new Point(mouseX, mouseY);
            invalidateDisplayList();
        }

        private function removeCrosshairs(e:MouseEvent):void
        {
            /* the mouse left the chart area, so throw away any stored coordinates and redraw */
            _crosshairs = null;
            invalidateDisplayList();
        }

        private function updateTrackBounds(dataVals:Array):void
        {
            /* store the bounding rectangle of the selection, in a normalized data-based rectangle */
            dRight = Math.max(tX, dataVals[0]);
            dLeft = Math.min(tX, dataVals[0]);
            dBottom = Math.min(tY, dataVals[1]);
            dTop = Math.max(tY, dataVals[1]);

            invalidateProperties();
            invalidateDisplayList();
        }
    }
}